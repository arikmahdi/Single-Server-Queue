# -*- coding: utf-8 -*-
"""011163119.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dOgr_xNA2Ysji-xXIlF4W9Dwgyh8ZxdX
"""

import numpy as np

np.random.seed(0)

 
class SSQ:

    def __init__(self,a):

        self.input_value = a
        #self.interarrivals= [0.397937254081555, 0.6279653814829189, 0.4616115729020344, 0.39360057615863536, 0.2755242455477496, 0.5190796474718047, 0.2877595995843199, 1.1117622065163284, 1.657456091026907, 0.24180105045112665, 0.7844480699845842, 0.3763370547682942, 0.41971642336941145, 1.2991270769627203, 0.03684267745642394, 0.04558051455950024, 0.010212793342112475, 0.8937438398074441, 0.7528921159326077, 1.0201571404727754]
        #self.service_times= [4.998788389616904, 2.08681142663519, 0.8046082961968591, 1.9714967699441972, 0.16363673537970563, 1.3278614523096948, 0.20114858754593876, 3.762746584598984, 0.9591754618043763, 0.6962354337909832, 0.3994644590175899, 1.9347312903447555, 0.7918071411940105, 1.0924351189278956, 0.02465914316109906, 1.2497952079533172, 1.2310956811969116, 1.2474123645480066, 3.7412896023633304, 1.4886806462454891]

        self.interarrivals = list(np.random.exponential(.5, 160))
        self.service_times = list(np.random.exponential(1.3, 160))
        print("Interarrival time : ",self.interarrivals)
        print("Service time : ",self.service_times)
        self.clock = 0.0

        self.next_arrival = self.interarrivals.pop(0)
        self.next_departure1 = float('inf')
        self.next_departure2 = float('inf')

        self.num_in_queue = 0
        self.times_of_arrivalqueue = []  # store times of arrivals who are waiting in the queue
        self.service_times_in_queue = []  # store service times of waiting customers in the queue

        self.total_delay   = 0.0
        self.num_of_delays = 0.0
        self.area_under_q  = 0.0
        self.area_under_b  = 0.0

        self.server1_status  =  0  # server 1  # 0 for IDLE , 1 for BUSY
        self.server2_status  =  0  # server 2
        self.last_event_time =  0.0  # we will need to store last event clock time

        self.Q_t = 0
        self.B_t_server1 = 0
        self.B_t_server2 = 0

    def start(self):
        while self.num_of_delays < 60:
            self.timing()
        self.calculation_overall()


    def timing(self):

        self.clock = min(self.next_arrival, self.next_departure1, self.next_departure2)
        self.update_register()

        if self.next_arrival < self.next_departure1 and self.next_arrival < self.next_departure2:
            print("Arrival at Clock:" + str(self.clock))
            self.arrival()

        else:
            if self.next_departure1 < self.next_departure2:
                print("Departure from server1 at Clock:" + str(self.clock))
                self.departure(1)
            else:
                print("Departure from server2 at Clock:" + str(self.clock))
                self.departure(2)

        print("Server 1 Status:" + str(self.server1_status))
        print("Server 2 Status:" + str(self.server2_status))

        print("Next Arrival Time: " + str(self.next_arrival))
        print("Next Departure from server 1 Time: " + str(self.next_departure1))
        print("Next Departure from server 2 Time: " + str(self.next_departure2))
        #Queue
        print("Times of arrivals in Queue: " + str(self.times_of_arrivalqueue))
        print("Service times in Queue: " + str(self.service_times_in_queue))
        print("Number of Delays: " + str(self.num_of_delays))
        print("Total Delay:" + str(self.total_delay))
        #area
        print("area under Q(t):", self.Q_t)
        print("area under B(t) for server1:", self.B_t_server1)
        print("area under B(t) for server2:", self.B_t_server2)
        print(" ")

    def arrival(self):
        self.next_arrival += self.interarrivals.pop(0)  # Schedule next arrival time = arrival + next interarrival time
        if self.server1_status == 0:         # Server IDLE

            self.server1_status = 1  # Make server BUSY

            delay = 0.0  # so delay is zero

            self.total_delay += delay

            self.num_of_delays += 1  # increase the number of customers delayed

            # schedule next departure, pop the first element of service_times list to get service time of this customer
            self.next_departure1 = self.clock + self.service_times.pop(0)  # schedule departure of this customer in server 1

        elif self.server2_status == 0:  # Server IDLE

            self.server2_status = 1  # make server BUSY

            delay = 0.0  # so delay is zero

            self.total_delay += delay

            self.num_of_delays += 1  # increase the number of customers delayed

            # schedule next departure, pop the first element of service_times list- to get service time of this customer
            self.next_departure2 = self.clock + self.service_times.pop(0)  # schedule departure of this customer in server 2

        else:
            # increase queue length, this customer will have to wait in the queue
            self.num_in_queue += 1

            # store the arrival time and service time of this customer in seperate lists

            self.times_of_arrivalqueue.append(self.clock)   #Use for next arrival count
            
            self.service_times_in_queue.append(self.service_times.pop(0))  # implemented for shortest job first(SJF)

    def departure(self, s):
        # check number of customers in the queue
        if self.num_in_queue == 0:  # if queue is empty
            if s == 1:
                # make server IDLE
                self.server1_status = 0
                # schedule next departure= infinity
                self.next_departure1 = float('infinity')

            else:
                # make server IDLE
                self.server2_status = 0
                # schedule next departure= infinity
                self.next_departure2 = float('infinity')
        else:
            # if queue not empty, pop one customer, decrease queue length
            self.num_in_queue -= 1
            self.num_of_delays += 1
            # AS FIFO, pop first arrival and service time from the queue. IF LIFO we have to pop last arrival and service time
            # For SJF, find the index of minimum service time from  service_times_in_queue list.
            # Then pop the arrival of that index from times_of_arrivalqueue for delay count and others.

            if int(self.input_value) == 1:  # FOR FIFO

                arrival = self.times_of_arrivalqueue.pop(0)

                delay = self.clock - arrival
                self.total_delay += delay
                if s == 1:
                    self.next_departure1 = self.clock + self.service_times_in_queue.pop(0)
                else:
                    self.next_departure2 = self.clock + self.service_times_in_queue.pop(0)

            elif int(self.input_value) == 2:  #FOR LIFO
                arrival = self.times_of_arrivalqueue.pop()

                delay = self.clock - arrival
                self.total_delay += delay
                if s == 1:
                    self.next_departure1 = self.clock + self.service_times_in_queue.pop()
                else:
                    self.next_departure2 = self.clock + self.service_times_in_queue.pop()

            elif int(self.input_value) == 3: #FOR SJF

                index_of_shortest_service_in_queue = self.service_times_in_queue.index(min(self.service_times_in_queue))
                arrival = self.times_of_arrivalqueue.pop(index_of_shortest_service_in_queue)

                delay = self.clock - arrival
                self.total_delay += delay
                if s == 1:
                    self.next_departure1 = self.clock + self.service_times_in_queue.pop(index_of_shortest_service_in_queue)
                else:
                    self.next_departure2 = self.clock + self.service_times_in_queue.pop(index_of_shortest_service_in_queue)

    def update_register(self):
        time_difference = self.clock - self.last_event_time

        self.last_event_time = self.clock
        #
        self.Q_t += time_difference * self.num_in_queue
        self.B_t_server1 += time_difference * self.server1_status
        self.B_t_server2 += time_difference * self.server2_status


    def calculation_overall(self):   #after simulation

        avg_delay = self.total_delay / self.num_of_delays
        print("Average delay =", avg_delay)

        expected_num_of_customer_in_queue = self.Q_t / self.clock
        print("Expected number of customers in queue =", expected_num_of_customer_in_queue)

        expected_utilization_of_server1 = self.B_t_server1 / self.clock
        print("Expected utilization of the server 1 =", expected_utilization_of_server1)

        expected_utilization_of_server2 = self.B_t_server2 / self.clock
        print("Expected utilization of the server 2 =", expected_utilization_of_server2)
   

option=input("press 1 for FIFO \n      2 for LIFO\n      3 for SJF\n input: ")
simulation = SSQ(option)  # create SSQ object; __init__ is called
simulation.start()

